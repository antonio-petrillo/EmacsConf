#+title: emacs configuration

* Yet another rewrite of my config
Each year I take a day or two to rewrite my vanilla *emacs* config from scratch.
Every time I do so it become more polished and performant, it is also a way to discover new amazing packages, so this is my *2024* emacs conf.
It is clear that it mimics [[https:github.com/doomemacs/doomemacs][Doom Emacs]] as I'm an happy doom user, but I also like to use a config in which I know what's inside and how it configured.
I also take a lot of inspiration from:
+ [[https://protesilaos.com/emacs/dotemacs][Protesilaos]] 
+ [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Karthinks]]
+ [[https://systemcrafters.net/][System Crafters]]
+ [[https:github.com/doomemacs/doomemacs][Doom Emacs]]
+ [[https:emacsredux.com][Emacs Redux]]
+ [[https://github.com/bbatsov/prelude/tree/master][Prelude Emacs]]

* Early Init
The *early init* is based on the one provided by [[https://protesilaos.com/emacs/dotemacs][Protesilaos]].
** Basic configuration
First thing first, here are some basic configuration, like /disable/ startup screen or set short answer.
#+begin_src emacs-lisp :tangle early-init.el
(setq frame-resize-pixelwise t
      frame-inhibit-implied-resize t
      frame-title-format '("%b")
      ring-bell-function 'ignore
      use-dialog-box t
      use-file-dialog nil
      use-short-answers t
      package-enable-at-startup nil ;; for straight.el
      custom-file (make-temp-file "emacs-custom-") ;; avoid custom file
      inhibit-startup-screen t
      inhibit-splash-screen t
      inhibit-startup-buffer-menu t)

(menu-bar-mode 1)
(scroll-bar-mode -1)
(tool-bar-mode -1)

(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Garbage collector hack
The most important part to know are the /hack/ made to improve the performance at startup.
As [[https://protesilaos.com/emacs/dotemacs][Protesilaos]] explains in his config, set the *garbage collector threshold* for the whole emacs instance life to the highest possible is a bad idea even though if it improve the startup time, on the long run worsen the performance.
The /hack/ consist in setting the *threshold* to the highest value at startup and after that restore to a more sensible value.
#+begin_src emacs-lisp :tangle early-init.el
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)

(defvar nto/file-name-handler-alist file-name-handler-alist)

(defvar nto/vc-handled-backends vc-handled-backends)

(setq file-name-handler-alist nil
      vc-handled-backends nil)

(add-hook 'emacs-startup-hook
	  (lambda ()
	    (setq gc-cons-threshold (* 1024 1024 100) ;; 100 MB 
		  gc-cons-percentage 0.2
		  file-name-handler-alist nto/file-name-handler-alist
		  vc-handled-backends nto/vc-handled-backends)))
#+end_src

** Whitescreen flash on startup
Here another nice /hack/ to avoid the initial flash on opening emacs, also taken from Protesilaos config.
#+begin_src emacs-lisp :tangle early-init.el

;; (defun nto/avoid-initial-flash-of-light ()
;;   (set-face-attribute 'default nil :background "#000000" :foreground "#ffffff")
;;   (set-face-attribute 'mode-line nil :background "#000000" :foreground "#ffffff" :box 'unspecified))

;; (nto/avoid-initial-flash-of-light)
#+end_src

** Setting frame parameters
Set *initial* & *default* frame parameters, the first is obviously for the first frame, the latter is used on when new frames are created, i.e. on most of the ~C-x 5~ commands.
#+begin_src emacs-lisp :tangle early-init.el
(defun nto/set-frame-params()
  (mapc (lambda (target-list)
		  (add-to-list target-list '(width . (text-pixels . 900)))
		  (add-to-list target-list '(height . (text-pixels . 600)))
		  (add-to-list target-list '(scroll-bar-width . 7)))
		'(default-frame-alist initial-frame-alist)))

(nto/set-frame-params)
#+end_src
Ô∏è *early-init.el* ends here.

* Init
The next step is load the good old ~init.el~, here it is possible to enable, or not, the various piece of the configuration.
Every piece can (better say should, since I didn't made any test) be omitted with few exception.
The ones that are always required are:
+ ~init-config~
+ ~init-core~
+ ~init-evil~
** Bootstrap Straight.el
As package manager I prefer to use [[https://github.com/radian-software/straight.el][straight]] as, in my (short) experience, let me build a truly reproducible config that works on all operating systems that I use.
The first part here is the bootstrap and the config of straight.
The bootstrap is the only part that I'm not sure it will work on every machine, once I had to modify the code to install it on /windows 10/, but still is a good guideline.
Straight is configured for:
+ integrate with src_emacs-lisp{use-package}

#+begin_src emacs-lisp :tangle init.el :mkdirp yes
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(setq straight-use-package-by-default t)
(setq straight-vc-git-default-clone-depth 1)
(setq straight-recipes-gnu-elpa-use-mirror t)
(setq straight-check-for-modifications '(check-on-save find-when-checking))
(setq straight-check-for-modifications nil)
(setq use-package-always-defer t)
#+end_src

** Global variable configuration
Now a couple of *variable* configuration that will be used in the remaining code.
#+begin_src emacs-lisp :tangle init.el :mkdirp yes
(setq make-backup-files nil
      backup-inhibited nil
      auto-save-default nil
	  initial-buffer-choice t
      create-lockfiles nil
	  winner-mode t)

(when (native-comp-available-p)
  (setq native-comp-async-report-warnings-errors 'silent
	native-compile-prune-cache t))

(setq custom-safe-themes t)
#+end_src

** Load modules
Here the load path is extended to with the /lisp/ directory which contains all the modules that I wrote.
Each ~require~ load a different module.
#+begin_src emacs-lisp :tangle init.el :mkdirp yes
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

(require 'init-config)
(require 'init-core)
(require 'init-evil)
(require 'init-help)
(require 'init-buffer)
(require 'init-editing)
(require 'init-completion)
(require 'init-search)
(require 'init-dired)
(require 'init-ui)
(require 'init-writing)
(require 'init-font)
(require 'init-window)
(require 'init-workspaces)
(require 'init-magit)
(require 'init-project)
(require 'init-embark)
(require 'init-term)
(require 'init-org)
(require 'init-mouse)
(require 'init-browser)
(require 'init-os)
(require 'init-prog)
(require 'init-app)

(when (eq system-type 'gnu/linux)
  (require 'init-exwm))
#+end_src

* Modules
** Module ~init-config.el~
Some config has to change based on the machine I'm using, like font, font-size, theme and etcetera.
A good thing to do is encapsulate all of them in a config file and load from there.
*** Load external config
Here a simple, maybe too simple, way to load config which is not in =emacs-user-directory=.
#+begin_src emacs-lisp :tangle "lisp/init-config.el" :mkdirp yes
(setq nto/conf-dir-name ".ntomacs.d/")
(setq nto/conf-name "config.el")

(defun nto/create-default-config (template-src conf-dest)
  "Create the config file, with template"
  (let ((template (expand-file-name template-src user-emacs-directory)))
	(copy-file template conf-dest)))

(defun nto/load-or-create-config-file()
  "If `nto/conf-dir-name' directory don't exist create it.
If `nto/conf-name' file don't exist create it.
Finally add the file to the load path and `require' it"
  (let* ((parent-user-emacs-directory (file-name-directory
									   (directory-file-name user-emacs-directory)))
		 (conf-dir (concat parent-user-emacs-directory nto/conf-dir-name))
		 (conf-path (concat conf-dir nto/conf-name)))
	(unless (file-directory-p conf-dir)
	  (make-directory conf-dir :parents)) ;; create conf dir if not exist
	(unless (file-exists-p conf-path)
	  (nto/create-default-config "snippets/config-template.el" conf-path)) ;; create conf file if not exist
	(add-to-list 'load-path conf-dir) ;; add to load path
	(require 'config))) ;; load personal config

(nto/load-or-create-config-file)
#+end_src
*** End
Module ~init-config.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-config.el" :mkdirp yes
(provide 'init-config)
#+end_src

** Module ~init-core.el~
Configuration that, in my opinion, don't belong to *early-init.el* nor *init.el*..
*** Modify default keybindings
Here I inserted the /built-in/ configuration that are not required at startup.
#+begin_src emacs-lisp :tangle "lisp/init-core.el" :mkdirp yes
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-j"))
(global-unset-key (kbd "M-a"))
(global-unset-key (kbd "C-;"))

(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src

*** Enabling modes
+ /recentf/, completion systems suggests recently opened files first
+ /delete-selection/, when past from kill ring don't add the overwritten text to the kill ring
+ /auto-revert/, automatically ~revert-buffer~, only in the focused buffer, if the underlying file on disk change
#+begin_src emacs-lisp :tangle "lisp/init-core.el" :mkdirp yes
(global-auto-revert-mode 1)
(delete-selection-mode 1)
(recentf-mode t)
#+end_src

*** Modify behaviour
Change the behaviour of the modes listed above and other basic settings:
+ /vc-follow-symlinks/, to follow symlinks in *dired* 
+ /confirm-kill-processes/, don't ask to kill buffer (i.e. term buffer) when quitting emacs 
#+begin_src emacs-lisp :tangle "lisp/init-core.el" :mkdirp yes
(setq auto-revert-verbose t
	  vc-follow-symlinks t
	  confirm-kill-processes nil
	  load-prefer-newer t
	  recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
						,(expand-file-name "eln-cache/" user-emacs-directory)
						,(expand-file-name "etc" user-emacs-directory)
						,(expand-file-name "var" user-emacs-directory)))
#+end_src

*** Add packages
+ /GCMH/ for a better garbage collector
+ /use-package/ to ensure that it will use the latest version
+ /no-littering/ to prevent emacs home directory cluttering
+ /consult/ made available to all the other modules
+ /popper/ to configure popup rules, it's here so I don't need to add as dependencies in ~:after~ clause whenever I need it
+ /repeat-mode/ for repeated keymaps
#+begin_src emacs-lisp :tangle "lisp/init-core.el" :mkdirp yes
(use-package gcmh
  :demand t
  :config (gcmh-mode))

(use-package use-package)

(use-package no-littering
  :demand t)

(use-package consult
  :bind
  (("M-y" . consult-yank-pop)))

;; magit fix transient bug, should be fixed in emacs 30.x
(use-package magit)

(use-package transient
  :straight t
  :defer t)

(use-package popper
  :bind (("C-`" . popper-toggle)
		 ("M-`" . popper-cycle)
		 ("C-M-`" . popper-toggle-type))
  :init
  (setq popper-reference-buffers
		'("\\*Messages\\*"
		  "Output\\*$"
		  "\\*scratch"
		  "\\*Async Shell Command\\*"
		  help-mode
		  compilation-mode))
  (popper-mode +1)
  (popper-echo-mode +1))

(use-package repeat
  :config
  (setq repeat-on-final-keystroke t)
  (setq set-mark-command-repeat-pop t)
  (repeat-mode 1))
#+end_src

*** End
Module ~init-core.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-core.el" :mkdirp yes
(provide 'init-core)
#+end_src

** Module ~init-evil.el~
*** Escape advice
Required to avoid strange behaviour when pressing ~(kbd  "<escape>)~
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(defadvice keyboard-escape-quit
	(around keyboard-escape-quit-dont-close-windows activate)
  (let ((buffer-quit-function (lambda () ())))
	ad-do-it))
#+end_src

*** Leader keys setup
I really like the concept of a leader key to access all the shortcuts, basically it transform all the keybindings in a walk on a [[https://en.wikipedia.org/wiki/Trie][prefix tree]].
I define two leader:
+ =SPC= for global shortcuts, =C-SPC= in insert mode
+ =m= as local leader for specific modes, =C-m= in insert mode
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package general
  :after evil
  :init
  (general-create-definer nto/leader
	:states '(normal insert visual emacs)
	:keymaps 'override
	:prefix "SPC"
	:global-prefix "C-SPC")

  (general-create-definer nto/local-leader
	:states '(normal visual)
	:prefix "m"
	:global-prefix "C-m")

  (nto/leader "?" '(which-key-show-top-level :wk "?"))
  (general-evil-setup))
#+end_src

*** EVIL setup
I learned first vim and only after switched to *Emacs* for this reason I prefer to stick with the modal editor approach.
For a couple of months I sticked to the *default* bindings and learned (not in deepth) them, and honestly they are not that bad as everybody says, so I mix the twos, doing so I've lost some vim bindings but I don't use them anyway.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll nil)
  (setq evil-want-C-i-jump nil)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-undo-system 'undo-fu)
  (setq evil-search-module 'evil-search)
  (setq evil-split-window-below nil)
  (setq evil-vsplit-window-right nil)
  (setq evil-auto-indent nil)
  (setq undo-limit (* 80 (* 1024 1024))) ;; 80 Mb see, https://tecosaur.github.io/emacs-config/config.html#better-defaults
  (setq evil-want-fine-undo t)
  (evil-mode 1)
  :config
  (setq evil-overriding-maps nil)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-a") 'beginning-of-line)
  (define-key evil-insert-state-map (kbd "C-e") 'end-of-line)
  (define-key evil-insert-state-map (kbd "C-n") 'next-line)
  (define-key evil-insert-state-map (kbd "C-p") 'previous-line)
  (define-key evil-insert-state-map (kbd "C-d") 'delete-char)
  (define-key evil-normal-state-map (kbd "C-a") 'beginning-of-line)
  (define-key evil-normal-state-map (kbd "C-e") 'end-of-line)
  (define-key evil-normal-state-map (kbd "C-n") 'next-line)
  (define-key evil-normal-state-map (kbd "C-p") 'previous-line)
  (define-key evil-normal-state-map (kbd "C-f") 'forward-char)
  (define-key evil-normal-state-map (kbd "C-b") 'backward-char)
  (define-key evil-normal-state-map (kbd "C-d") 'delete-char)
  (define-key evil-motion-state-map "0" 'evil-beginning-of-line)
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

*** Top level mnemonics
Here I set a couple of bindings but most important the top level /next key/ for the global leader keybindings.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package emacs
  :after general
  :init
  (nto/leader
	"SPC" '(execute-extended-command :which-key "M-x but faster")
	"<escape>" '(keyboard-escape-quit :wk "quit")
	"A" '(:ignore t :wk "Apps")
	"g" '(:ignore t :wk "git")
	"j" '(:ignore t :wk "jump")
	"jc" '(consult-line :wk "consult line")
	"l" '(:ignore t :wk "language")
	"o" '(:ignore t :wk "open")
	"p" '(:ignore t :wk "project")
	"r" '(:ignore t :wk "rotate")
	"s" '(:ignore t :wk "search")
	"t" '(:ignore t :wk "toggle")
	"u" '(universal-argument :wk "universal")))
#+end_src

*** Evil collection
Evil mode is really great, but set it up correctly in every mode and context is a hustle, so I rely on *evil collection* even tough I don't like some aspect of it (like *magit* configuration).
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-collection
  :after evil
  :init
  (setq evil-collection-magit-use-z-for-folds nil)
  (evil-collection-init)
  :config
  (evil-collection-unimpaired-mode -1)
  (global-evil-collection-unimpaired-mode -1))
#+end_src

*** Evil snipe
I don't like the default snipe operation so I replaced with *evil-snipe*, note that this package is not related to *evil*, you can use with default bindings. 
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-snipe
  :after evil
  :init
  (evil-snipe-mode +1)
  (evil-define-key '(normal motion) evil-snipe-local-mode-map
	"s" 'evil-snipe-s
	"S" 'evil-snipe-S
	"f" 'evil-snipe-f
	"F" 'evil-snipe-F)

  ;; (evil-define-key 'operator evil-snipe-local-mode-map
  ;; 	"z" 'evil-snipe-s
  ;; 	"Z" 'evil-snipe-S
  ;; 	"x" 'evil-snipe-x
  ;; 	"X" 'evil-snipe-X)

  (evil-define-key 'motion evil-snipe-override-local-mode-map
	"f" 'evil-snipe-f
	"F" 'evil-snipe-F
	;; "t" 'evil-snipe-t
	;; "T" 'evil-snipe-T
	)

  (when evil-snipe-override-evil-repeat-keys
	(evil-define-key 'motion map
      ";" 'evil-snipe-repeat
      "," 'evil-snipe-repeat-reverse))

  :config
  (setq evil-snipe-scope 'buffer))
#+end_src

*** Evil escape
Reach for src_emacs-lisp{(kbd "<escape>")} each time is a bit annoying since it require me to move my hand from homerow, *evil-escape* solve this problem by pressing, in a brief period of time, src_emacs-lisp{(kbd "jk")}.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-escape
  :after evil
  :init
  (evil-escape-mode 1)
  :config
  (setq-default evil-escape-delay 0.2)
  (setq-default evil-escape-key-sequence "jk")
  (setq-default evil-escape-unordered-key-sequence nil))
#+end_src

*** Evil Lion
Provide =gl= and =gL= motion to align text.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-lion
  :after evil
  :init
  (evil-lion-mode))
#+end_src

*** Evil Visual Start
Allow =*= and =#= to search also for visual region.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-visualstar
  :after evil
  :init
  (global-evil-visualstar-mode))
#+end_src

*** Evil matchit
Add =%= motion to jump between matching arguments.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-matchit
  :after evil
  :init
  (global-evil-matchit-mode 1)
  (setq evilmi-may-jump-by-percentage nil))
#+end_src

*** Evil exato
Add =x= motion to match xml tags, works also for html (should work also for jsx).
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package exato
  :after evil
  :init
  (require 'exato)) ;; autoloads don't work properly
#+end_src

*** My evil movements
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(defmacro nto/build-url (url &rest params)
  `(format ,url ,@params))

(defun nto/web-search ()
  (interactive)
  (let ((base-url "https://google.com/search?q=%s")
		(param (if (region-active-p)
				   (buffer-substring-no-properties (region-beginning) (region-end))
				 (read-from-minibuffer "Search: "))))
	(browse-url (nto/build-url base-url param))))

(with-eval-after-load 'evil
  (evil-define-key '(normal visual) 'global
	(kbd "gs") #'nto/web-search
	(kbd "ga") #'beginning-of-line
	(kbd "ge") #'end-of-line
	(kbd "gJ") #'avy-goto-char-timer
	(kbd "gE") #'avy-goto-end-of-line))
#+end_src
*** Evil exchange
Add =gx= motion to exchange matched motions.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-exchange
  :after evil
  :init
  (setq evil-exchange-key (kbd "zx"))
  (setq evil-exchange-cancel-key (kbd "zX"))
  (evil-exchange-install))
#+end_src

*** Evil commentary
Add =gc= motion to comment code.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-commentary
  :after evil
  :init
  (evil-commentary-mode))
#+end_src

*** Evil Numbers
Increase number at point, work on base 2, 8, 10, 16 and more.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-numbers
  :after evil
  :init
  (evil-define-key '(normal visual) 'global (kbd "+") 'evil-numbers/inc-at-pt)
  (evil-define-key '(normal visual) 'global (kbd "_") 'evil-numbers/dec-at-pt))
#+end_src

*** End
Module ~init-evil.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(provide 'init-evil)
#+end_src

** Module ~init-org.el~
*** Header 
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
;;; init-org.el --- Description -*- lexical-binding: t; -*-

(straight-use-package 'org)
(require 'org)
#+end_src

*** Org parameters configuration
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(setq org-export-with-toc t
	  org-export-headline-levels 3
	  org-refile-use-outline-path 'file
	  org-outline-path-complete-in-steps nil
	  org-refile-allow-creating-parent-nodes 'confirm)

(setq org-confirm-babel-evaluate nil
	  org-src-window-setup 'current-window
      org-edit-src-content-indentation 0)

(setq org-cite-global-bibliography `(,(expand-file-name "assets/bibliography.bib" org-directory)))

(setq org-startup-indented t
	  org-pretty-entities t
	  org-use-sub-superscripts "{}"
	  org-hide-emphasis-markers nil
	  org-startup-with-inline-images t
	  org-image-actual-width '(300))

(advice-add 'org-refile :after 'org-save-all-org-buffers)
#+end_src

*** Disable annoying keybindings
As Protesilaos said in his config, org mode bind to many keys, so many that there are conflict.
On this regard, now I really appreciate how DoomEmacs tweaks all this little things.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(define-key org-mode-map (kbd "C-'") nil)
(define-key org-mode-map (kbd "C-,") nil)
(define-key org-mode-map (kbd "M-,") nil)
(define-key org-mode-map (kbd "M-;") nil)
#+end_src

*** Evil integration
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(with-eval-after-load 'org
  (nto/local-leader
	:keymaps 'org-mode-map
	"k" '(outline-up-heading :wk "previous header")
	"j" '(outline-next-visible-heading :wk "next header")
    "t" '(org-todo :wk "cycle todo")
	"c" '(org-ctrl-c-minus :wk "cycle bullets or insert separator")
    "m" '(:ignore t :wk "move heading")
    "ml" '(org-meta-left :wk "demote")
    "mh" '(org-meta-right :wk "promote")
    "mj" '(org-meta-up :wk "move up")
    "mk" '(org-meta-down :wk "move down")))
#+end_src

*** Org modern
A modern ui for org mode.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package org-modern
  :after org
  :defer t
  :custom
  (org-modern-table nil)
  :init
  (add-hook 'org-mode-hook #'org-modern-mode))
#+end_src

*** Org appear
Hide *emphasis* marker in org mode.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package org-appear
  :hook
  (org-mode . org-appear-mode))
#+end_src

*** TODO Org citar
Manage bibliography in org mode.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package citar
  :no-require
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-bibliography org-cite-global-bibliography)
  :hook
  (LaTex-mode . citar-capf-setup)
  (org-mode . citar-capf-setup)
  :bind
  (:map org-mode-map
		:package org
		("C-c b" . #'org-cite-insert)))

(use-package citar-embark
  :after citar embark
  :no-require
  :config
  (citar-embark-mode))
#+end_src

*** Denote
Installation of denote per pkm.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
;; checkout denote silos (for work notes)
(use-package denote
  :after general
  :init
  (setq denote-infer-keywords t)
  (setq denote-sort-keywords t)
  (setq denote-directory (expand-file-name "notes" org-directory))
  (setq denote-prompts '(title keywords))
  (setq denote-file-type 'org)
  (setq denote-known-keywords '("emacs" "programming" "algorithm" "datastructure"
								"pattern" "math" "art" "music"
								"film" "book" "philosophy" "meta"
								"linux" "windows" "fitness"))
  (setq denote-journal-extras-title-format 'day-date-month-year)
  (setq denote-journal-extras-directory (expand-file-name "journal" denote-directory))

  (add-hook 'dired-mode-hook #'denote-dired-mode)
  (add-hook 'find-file-hook #'denote-link-buttonize-buffer)

  (nto/leader
	"n" '(:ignore t :wk "denote")
	"nf" '(denote-open-or-create :wk "find")
	"nd" '(list-denote :wk "dired")
	"nr" '(denote-rename-file :wk "rename")
	"ni" '(denote-link-or-create :wk "link")
	"nb" '(denote-backlink :wk "backlink")
	"nj" '(denote-journal-extras-new-entry :wk "journal")
;;	"dq" '(denote-org-dblock-insert-links :wk "query") need further reading on this feature
	))
#+end_src

*** Denote menu
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package denote-menu
  :after denote
  :config
  (define-key denote-menu-mode-map (kbd "c") #'denote-menu-clear-filters)
  (define-key denote-menu-mode-map (kbd "/ r") #'denote-menu-filter)
  (define-key denote-menu-mode-map (kbd "/ k") #'denote-menu-filter-by-keyword)
  (define-key denote-menu-mode-map (kbd "/ o") #'denote-menu-filter-out-keyword)
  (define-key denote-menu-mode-map (kbd "e") #'denote-menu-export-to-dired))
#+end_src

*** Denote explore
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package denote-explore
  :straight (denote-explore :type git
						:host github
						:repo "pprevos/denote-explore")
  :after denote
  :custom
  (denote-explore-network-directory (expand-file-name "network" denote-directory))
  (denote-explore-network-filename "denote-network")
  :init
  (nto/leader
	"nJ" '(:ignore t :wk "janitor")
	"nJd" '(denote-explore-identify-duplicate-notes :wk "duplicate")
	"nJz" '(denote-explore-zero-keywords :wk "zero keywords")
	"nJs" '(denote-explore-single-keywords :wk "single keywords")
	"nJS" '(denote-explore-sort-keywords :wk "sort keywords")
	"nJr" '(denote-explore-rename-keywords :wk "rename keywords")

	"ne" '(:ignore t :wk "explore")
	"nen" '(denote-explore-network :wk "network")
	"nei" '(denote-explore-isolated-notes :wk "isolated")
	"ner" '(denote-explore-network-regenerate :wk "regenerate")
	"neb" '(denote-explore-degree-barchart :wk "degree chart")

	"ns" '(:ignore t :wk "statistics")
	"nsc" '(denote-explore-count-notes :wk "count notes")
	"nsC" '(denote-explore-count-keywords :wk "keywords notes")
	"nsb" '(denote-explore-keywords-barchart :wk "keywords chart")
	"nsx" '(denote-explore-extensions-barchart :wk "extensions chart")
	"nsB" '(denote-explore-degree-barchart :wk "degree chart")

	"nw" '(:ignore t  :wk "walk")
	"nwr" '(denote-explore-random-note :wk "note")
	"nwr" '(denote-explore-random-link :wk "link")
	"nwr" '(denote-explore-random-keyword :wk "keyword")))
#+end_src

*** TODO Denote citar
*** TODO Denote consult
*** End
Module ~init-org.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(provide 'init-org)
#+end_src

** Module ~init-help.el~
*** Helpful
For a better help system.
#+begin_src emacs-lisp :tangle "lisp/init-help.el" :mkdirp yes
(use-package helpful
  :init (setq evil-lookup-func #'helpful-at-point)
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key))
#+end_src

*** Which Key
This awesome package show all the possible ways to complete the current keybind or keychord, this has a great importance because it acts as a sort of spaced repetition.
Every time I forget the next key I can see all possible completion and continue from that point, each time that happen I will improve my memory.
#+begin_src emacs-lisp :tangle "lisp/init-help.el" :mkdirp yes
(use-package which-key
  :init
  (setq which-key-separator " ")
  (setq which-key-prefix-prefix "+")
  (setq which-key-show-early-on-C-h t)
  (setq which-key-idle-delay 0.5)
  (setq which-key-idle-secondary-delay 0.5)
  (which-key-mode +1)
  (which-key-setup-minibuffer))
#+end_src

*** Leader Help bindings
#+begin_src emacs-lisp :tangle "lisp/init-help.el" :mkdirp yes
(use-package emacs
  :after general
  :init
  (nto/leader
   "h" '(:ignore t :which-key "help")
   "he" '(view-echo-area-messages :wk "messages buffer")
   "hf" '(describe-function :wk "function")
   "hF" '(describe-face :wk "face")
   "hl" '(view-lossage :wk "lossage")
   "hL" '(find-library :wk "library")
   "hm" '(describe-mode :wk "mode")
   "hk" '(describe-key :wk "keybind")
   "hK" '(describe-keymap :wk "keymap")
   "hp" '(describe-package :wk "package")
   "ht" '(consult-theme :wk "load theme")
   "hv" '(describe-variable :wk "variable")))
#+end_src

*** End
Module ~init-help.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-help.el" :mkdirp yes
(provide 'init-help)
#+end_src

** Module ~init-buffer.el~
*** Dependencies
I use [[https://github.com/BurntSushi/ripgrep][ripgrep]] instead of *grep* and [[https://github.com/sharkdp/fd][fd]] instead of *find*, because they /claim/ to be faster.
They can be easily swapped for the standard unix version by changing:
+ src_emacs-lisp{consult-ripgrep} with src_emacs-lisp{consult-grep}
+ src_emacs-lisp{consult-fd} with src_emacs-lisp{consult-find}

*** Leader buffer & file bindings
#+begin_src emacs-lisp :tangle "lisp/init-buffer.el" :mkdirp yes
(use-package emacs
  :after general
  :init
  (nto/leader
	"b" '(:ignore t :which-key "buffer")
	"br"  '(revert-buffer :wk "revert")
	"bk"  '(kill-current-buffer :wk "kill")
	"bb"  '(consult-buffer :wk "switch")
	"bi"  '(ibuffer :wk "ibuffer")

	"f"  '(:ignore t :which-key "file")
	"ff" '(find-file :wk "find")
	"fg" '(consult-ripgrep :wk "ripgrep")
	"fF" '(consult-fd :wk "fd find")
	"."  '(find-file :wk "find")
	"fs" '(save-buffer :wk "save")
	"fr" '(consult-recent-file :wk "recent")))
#+end_src
*** Popup scratch buffer
Open /scratch/ as popup in current window.
#+begin_src emacs-lisp :tangle "lisp/init-buffer.el" :mkdirp yes
(use-package scratch-pop
  :init
  (nto/leader
	"bs" '(scratch-pop :wk "popup scratch")))
#+end_src
*** End
Module ~init-buffer.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-buffer.el" :mkdirp yes
(provide 'init-buffer)
#+end_src

** Module ~init-editing.el~
All the goodies for text editing and manipulation will be placed in this section.
*** Subword mode 
Consider camel case word as multiple word, for example *CamelCase* case will be treated by function, operations and commands as *Camel* and *Case* words as they were separated.
A nice use case, still using *CamelCase* as example, is when I want to delete only *Case* with a single src_emacs-lisp{(kbd "C-<backspace>").
A drawback is that, in a few rare case, I cannot treat a word as single object anymore, i.e. if I want to change *CamelCase* to *kebab-case* I cannot use anymore the operator *ciw* (change inner word) while the cursor on the word, I first need to select all the word and then use *ciw*.
Subword mode is built-in but I like it only in /org/ and /prog/ mode. 
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(add-hook 'prog-mode-hook 'subword-mode)
(add-hook 'org-mode-hook 'subword-mode)
#+end_src
Can be turned on globally with src_emacs-lisp{(global-subword-mode 1)}.
*** Whitespace mode
Copied from doom emacs, have this mode always on is too confusing, but sometime is good to use, like when I'm editing =makefiles=.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(setq whitespace-line-column nil
      whitespace-style
      '(face indentation tabs tab-mark spaces space-mark newline newline-mark
        trailing lines-tail)
      whitespace-display-mappings
      '((tab-mark ?\t [?ÔøΩ ?\t])
        (newline-mark ?\n [?ÔøΩ ?\n])
        (space-mark ?\  [?ÔøΩ] [?.])))
#+end_src
*** Backward Kill Word Hack
Change the behaviour of the default src_emacs-lisp{backward-kill-word}, the original implementation when invoked on whitespace character at the beginning of a line it delete backward until it reach a word, and everytime result in, imho,  /too much deletion/.
My version stop at the beginning of the line, if invoked agait it delete just one character, so it goes to end of the previous line.
The logic behind is the following:
Take the *current line position* and the *line position* after a src_emacs-lisp{backward-word}, which if called on whitespace goes backward until find a word.
If the two differ then src_emacs-lisp{backward-kill-word} will delete to much so I delete to the beggining of the line, otherwise call src_emacs-lisp{backward-kill-word}
The edge case to consider are:
if the cursor is at the beginning of the line
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(defun nto/backward-kill-word()
  "Same as `backward-kill-word' but if it is invoked on a white space character
at the beginning of the line it will stop at it, furthermore if it is invoked
on the beginning of the line it will go the end of the previous line instead
of delete the previous word."
  (interactive)
  (let ((same? (save-excursion
				 (let ((orig (line-number-at-pos (point)))
					   (dest (progn
							   (backward-word)
							   (line-number-at-pos (point)))))
				   (eq orig dest))))
		(start? (eq (point) (line-beginning-position))))
	(cond (start? (backward-delete-char 1))
		  (same? (backward-kill-word 1))
		  (:else (kill-line 0)))))

(global-set-key (kbd "C-<backspace>") 'nto/backward-kill-word)
#+end_src

*** Handling parentheses
Highlight matching parentheses and setting up src_emacs-lisp{electric-pair}, when enabled closing bracket are inserted automatically.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(show-paren-mode t)

(electric-pair-mode 1)
(push '(?{ . ?}) electric-pair-pairs)
#+end_src

*** Setup built-in parameters
Set type of line numbers and tabs width, also keybind to toggle line numbers.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(setq-default display-line-numbers-width 3)
(use-package emacs
  :after general
  :init
  (nto/leader
	"tl" '(display-line-numbers-mode :wk "line numbers"))
  (setq display-line-numbers-type 'relative)
  (setq tab-always-indent 'complete)
  (setq-default indent-tabs-mode t)
  (setq-default tab-width 4))
#+end_src

*** A butler for whitespace character
(require 'ws-butler)
(add-hook 'prog-mode-hook #'ws-butler-mode)
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package ws-butler
  :init
  (ws-butler-global-mode 1)
  :config
  (setq ws-butler-keep-whitespace-before-point nil))
#+end_src
*** Evil Multiedit
This awesome package let me select multiple occurrence of a text object and modify all them in one pass.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package evil-multiedit
  :after evil
  :init
  (evil-define-key 'normal 'global
	(kbd "M-a")   #'evil-multiedit-match-symbol-and-next
	(kbd "M-A")   #'evil-multiedit-match-symbol-and-prev)

  (evil-define-key 'visual 'global
	"R"           #'evil-multiedit-match-all
	(kbd "M-a")   #'evil-multiedit-match-and-next
	(kbd "M-A")   #'evil-multiedit-match-and-prev)

  (evil-define-key '(visual normal) 'global
	(kbd "C-M-a") #'evil-multiedit-restore)

  (with-eval-after-load 'evil-mutliedit
    (evil-define-key 'multiedit 'global
      (kbd "M-a")   #'evil-multiedit-match-and-next
      (kbd "M-S-a") #'evil-multiedit-match-and-prev
      (kbd "RET")   #'evil-multiedit-toggle-or-restrict-region)
    (evil-define-key '(multiedit multiedit-insert) 'global
      (kbd "C-n")   #'evil-multiedit-next
      (kbd "C-p")   #'evil-multiedit-prev)))
#+end_src
*** Evil Commenter
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package evil-commentary
  :after evil
  :config (evil-commentary-mode +1))
#+end_src

*** Evil Surround
Used to surround selected region, or word at point, with simple shortcuts.
A neat example, which is more of a memorandum for future me, is the following:
1. I want to surroung *this*
2. Place cursor on the text object *this*
3. Do =ysiw)=
   1. =y= yank
   2. =s= surround operator
   3. =i= inner
   4. =w= word
   5. =)= surround with this delimiter 
4. Done, the result is *(this)*
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package evil-surround
  :after general
  :general
  (:states 'operator
		   "s" 'evil-surround-edit
		   "S" 'evil-Surround-edit)
  (:states 'visual
		   "S" 'evil-surround-region
		   "gS" 'evil-Surround-region))
#+end_src

*** TODO Undo mechanism 
Evil don't have a proper undo system so I need to provide one, *undo-fu* is just the one I know and I'm good with it.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package undo-fu
  :after evil
  :init
  (general-define-key
   :states 'normal
   "u" 'undo-fu-only-undo
   "\C-r" 'undo-fu-only-redo))

(use-package undo-fu-session
  :after undo-fu
  :demand
  :init
  (setq undo-fu-session-incompatible-files
		'("/COMMIT_EDITMSG\\'"
		  "/git-rebase-todo\\'"))
  :config
  (global-undo-fu-session-mode))
#+end_src

**** TODO Add *undo-tree* configuration.

*** Enable code folding
I've tried a couple of packages for this purpose but this is the one that work well for me, furthermore it is built-in.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package emacs
  :hook (prog-mode . hs-minor-mode)
  :init
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (evil-define-key 'normal 'global
	(kbd "za") 'hs-toggle-hiding
	(kbd "zc") 'hs-hide-block
	(kbd "zo") 'hs-show-block))
#+end_src

*** Jump to point with visual enumeration
In other words *avy-jump*, it is easier to try than to explain.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package avy
  :after general
  :hook (after-init . avy-setup-default)
  :init (setq avy-style 'pre)
  (nto/leader
	"jj" '(avy-goto-char-timer :wk "char")
	"je" '(avy-goto-end-of-line :wk "end line")
	"jp" '(avy-goto-line-above :wk "above line")
	"jn" '(avy-goto-line-below :wk "below line")
	"jl" '(avy-goto-line :wk "line")
	"jw" '(:ignore t :wk "word")
	"jwp" '(avy-goto-word-0-above :wk "prev")
	"jwn" '(avy-goto-word-0-below :wk "next")))
#+end_src

*** Distraction free editing
Center text in buffer, hide modeline and just write.
When toggled on it works only when there is one window.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package darkroom
  :init
  (nto/leader
	"tz" '(darkroom-tentative-mode :wk "zen")))
#+end_src

*** Rotate text
Cycle word at point between a list of candidates.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package rotate-text
  :after general
  :config
  (add-to-list 'rotate-text-words '("len" "length" "size"))
  (add-to-list 'rotate-text-words '("int" "long"))
  (add-to-list 'rotate-text-words '("float" "double"))
  (add-to-list 'rotate-text-words '("true" "false"))
  (add-to-list 'rotate-text-words '("def" "defn" "fn" "defun"))
  (add-to-list 'rotate-text-words '("fun" "func" "function"))
  (add-to-list 'rotate-text-words '("True" "False"))
  (add-to-list 'rotate-text-words '("true" "false"))
  (add-to-list 'rotate-text-words '("t" "nil"))
  :init
  (global-set-key (kbd "M-r") 'rotate-text)
  (global-set-key (kbd "M-R") 'rotate-text-backward)
  (nto/leader
	"rt" '(rotate-text :wk "text")
	"rT" '(rotate-text-backward :wk "text")))
#+end_src

*** Auto format code on save
As usual, there are many packages to accomplish this, personally I like src_emacs-lisp{apheleia}, it's made by the same creator of src_emacs-lisp{straight.el}.
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(use-package apheleia
  :init
  (apheleia-global-mode +1))
#+end_src

**** Side note
This package come with a couple of auto-formatters preconfigured, but not for every language.
I.E. I need to provide one, like =cljfmt= for clojure.
*** End
Module ~init-editing.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-editing.el" :mkdirp yes
(provide 'init-editing)
#+end_src

** Module ~init-search.el~
*** Deadgrep
Nice frontend for =ripgrep=
#+begin_src emacs-lisp :tangle "lisp/init-search.el" :mkdirp yes
(use-package deadgrep
  :init
  (global-set-key (kbd "<f5>") #'deadgrep))
#+end_src

*** End
Module ~init-search.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-search.el" :mkdirp yes
(provide 'init-search)
#+end_src

** Module ~init-completion.el~
Enhance the default emacs completion system.
*** Completion system
I've tried almost all emacs completion systems, from helm to ivy, and all have their strength, at the end I've chosen *vertico*.
Most of this configuration is taken from the [[https://github.com/minad/vertico][documentation]].
*Vertico mouse* add support for mouse selection in minibuffer completion.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package vertico
  :demand t
  :hook
  ((minibuffer-setup . vertico-repeat-save)
   (rfn-eshadow-update-overlay . vertico-directory-tidy))
  :general
  (:keymaps 'vertico-map
            "C-j" #'vertico-next
            "C-k" #'vertico-previous
            "<escape>" #'minibuffer-keyboard-quit
            "M-<backspace>" #'vertico-directory-delete-word)
  :init
  (setq vertico-grid-separator "       ")
  (setq vertico-grid-lookahead 50)
  (setq vertico-buffer-display-action '(display-buffer-reuse-window))
  (setq vertico-multiform-categories
        '((file indexed)
          (consult-grep buffer)
          (consult-location)
          (imenu buffer)
          (library reverse indexed)
          (t reverse)))
  (setq vertico-multiform-commands
        '(("flyspell-correct-*" grid reverse)
          (org-refile grid reverse indexed)
          (consult-yank-pop indexed)
          (consult-flycheck)
          (consult-lsp-diagnostics)))
  :custom
  (vertico-cycle t)
  :config
  (vertico-mode 1))

(use-package vertico-mouse
  :after vertico
  :straight nil
  :load-path "straight/repos/vertico/extensions/"
  :init
  (vertico-mouse-mode))
#+end_src

*** Additional information
As default *vertico* doesn't provide to much information in completion minibuffer, this job is done by *marginalia* which provide information on the current minibuffer action, either file name, commands and variables.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package marginalia
  :after vertico
  :init
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  (marginalia-mode)
  (with-eval-after-load 'projectile
    (add-to-list 'marginalia-command-categories '(projectile-find-file . file))))
#+end_src

*** Match completion and ordering
As for the additional information, *vertico* does nothing, as emacs by itself, to sort the completion or to match them, this is accomplished by *orderless*.
With this package I can match, in any order, a command by only a few letters, there are many style of completion, I use the basic ones.
For example, I want to search for src_emacs-lisp{extended-execute-command}, with orderless it can be matched with any of the following combination:
+ ext ex comm
+ xten ut man
+ man exe ded
+ *many more*

#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package orderless
  :init
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

*** Completion at point popup 
A vscode like completion at point.
**** Corfu
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(when (display-graphic-p)
  (use-package corfu
    :straight (corfu :files (:defaults "extensions/*")
                     :includes (corfu-popupinfo corfu-history))
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-scroll-margin 5)
	(corfu-quit-no-match 'separator)
    :bind
    (:map corfu-map
          ("C-j" . corfu-next)
          ("C-k" . corfu-previous)
          ("M-d" . corfu-popupinfo-toggle)
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))
    ;; :config
    ;; (setq corfu-auto t
    ;;       corfu-quit-no-match 'separator)
    :init
    (global-corfu-mode)
    (corfu-popupinfo-mode)))
#+end_src
**** Corfu terminal
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(unless (display-graphic-p)
  (use-package corfu-terminal
    :when (eq system-type 'gnu/linux)
    :straight (corfu-terminal :type git
                              :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-scroll-margin 5)
    :bind
    (:map corfu-map
          ("C-j" . corfu-next)
          ("C-k" . corfu-previous)
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))
    :config
    (setq corfu-auto t
          corfu-quit-no-match 'separator)
    :init
    (corfu-terminal-mode +1)))
#+end_src
***** Corfu terminal doc
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(unless (display-graphic-p)
  (use-package corfu-doc-terminal
	:after corfu-terminal
    :when (eq system-type 'gnu/linux)
    :straight (corfu-doc-terminal :type git
								  :repo "https://codeberg.org/akib/emacs-corfu-doc-terminal.git")
    :init
    (corfu-doc-terminal-mode +1)))
#+end_src
**** Cape
Extension CAPF for corfu.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el"  :mkdirp yes
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :after corfu
  :bind (("C-c c p" . completion-at-point) ;; capf
         ("C-c c t" . complete-tag)        ;; etags
         ("C-c c d" . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c c h" . cape-history)
         ("C-c c f" . cape-file)
         ("C-c c k" . cape-keyword)
         ("C-c c s" . cape-elisp-symbol)
         ("C-c c e" . cape-elisp-block)
         ("C-c c a" . cape-abbrev)
         ("C-c c l" . cape-line)
         ("C-c c w" . cape-dict)
         ("C-c c :" . cape-emoji)
         ("C-c c \\" . cape-tex)
         ("C-c c _" . cape-tex)
         ("C-c c ^" . cape-tex)
         ("C-c c &" . cape-sgml)
         ("C-c c r" . cape-rfc1345))
  :init
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  (add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
)
#+end_src
**** Add nerd icons for corfu
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package nerd-icons-corfu
  :after corfu
  :init
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
*** Snippets
I use yasnippet to generate and use template, divided by mode.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el"  :mkdirp yes
(use-package yasnippet
  :init
  (setq yas-snippet-dirs `(,(concat user-emacs-directory "snippets")))
  (yas-global-mode 1))
#+end_src

*** End
Module ~init-completion.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(provide 'init-completion)
#+end_src

** Module ~init-dired.el~
nothing to say, just one of the killer feature of emacs.
*** Basic setup
Change the default bindings, evil integration and tweaks some behaviour.
+ src_emacs-lisp{delete-by-moving-to-trash}, on delete move to trash instead of perform a src_bash{rm} on the selection
+ src_emacs-lisp{dired-listing-switches}, src_emacs-lisp{ls} switches to use
+ src_emacs-lisp{dired-dwim-target}, *do what I mean* on target, i.e. with 2 dired buffer copy from one to another without asking
+ src_emacs-lisp{dired-kill-when-opening-new-dired-buffer}, delete current buffer when entering a new directory
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package dired
  :straight (:type built-in)
  :after evil
  :general
  (nto/leader
	"fd" '(dired-jump :wk "find file"))
  :config
  (evil-define-key '(normal insert) dired-mode-map
	"h" 'dired-up-directory
	"l" 'dired-find-file
	"m" 'dired-mark
	"u" 'dired-unmark
	"t" 'dired-toggle-marks
	"C" 'dired-do-copy
	"D" 'dired-do-delete
	"J" 'dired-goto-file
	"M" 'dired-do-chmod
	"O" 'dired-do-chown
	"R" 'dired-do-rename
	"T" 'dired-do-touch
	"Y" 'dired-copy-filename-as-kill
	"+" 'dired-create-directory
	"-" 'dired-up-directory
	(kbd "<return>") 'dired-find-file
	(kbd "% l") 'dired-downcase
	(kbd "% u") 'dired-upcase
	(kbd "; d") 'epa-dired-do-decrypt
	(kbd "; e") 'epa-dired-do-encrypt)
  :init
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches "-lah")
  (setq dired-dwim-target t)
  (setf dired-kill-when-opening-new-dired-buffer t))
#+end_src

*** Hide hidden files
I like the src_bash{ls -a} switch but often I don't need all that information, I prefer to hide all the dotfiles and show them only when needed.
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package dired-hide-dotfiles
  :after dired
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :config
  (evil-define-key 'normal dired-mode-map
    "H" 'dired-hide-dotfiles-mode))
#+end_src

*** Styling
Just *all-the-icons* integration, I've also tried [[https://github.com/alexluigit/dirvish][dirvish]], but for now it didn't convince me.
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package all-the-icons-dired
  :when (display-graphic-p)
  :defer t
  :hook (dired-mode .all-the-icons-dired-mode))

(use-package diredfl
  :after dired
  :init
  (diredfl-global-mode 1))
#+end_src

*** Trash directory
With dired is not so obvious how to work with *Trash* folder, luckily the *trashed* package fix that.
Here there is a good use case for *local leader* keybinding, which work only on *trashed-mode*.
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package trashed
  :init
  (nto/local-leader :keymaps 'trashed-mode-map
	"r" '(trashed-do-restore :wk "restore")
	"d" '(trashed-do-delete :wk "delete")))
#+end_src

*** TODO Missing feature [0/4]
+ [ ] Mounted media integration
+ [ ] Image preview
+ [ ] Open in external application (like *mpv*)
+ [ ] *ffmpeg* dwim integration, see [[https://xenodium.com/dwim-shell-command-with-template-prompts/][here]]

*** End
Module ~init-dired.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(provide 'init-dired)
#+end_src

** Module ~init-ui.el~
*** Highlight cursor
Highlight cursor when jumping between buffers.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package pulsar
  :after consult
  :init
  (pulsar-global-mode 1)
  (add-hook 'consult-after-jump-hook #'pulsar-recenter-top)
  (add-hook 'consult-after-jump-hook #'pulsar-reveal-entry)
  (add-hook 'imenu-after-jump-hook #'pulsar-recenter-top)
  (add-hook 'imenu-after-jump-hook #'pulsar-reveal-entry)
  :config
  (setq pulsar-pulse t
		pulsar-delay 0.055
		pulsar-iteration 10
		pulsar-face 'pulsar-magenta
		pulsar-highlight-face 'pulsar-yellow))
#+end_src
*** Hide modeline
Self explanatory, I also add a keybinding to toggle this option on the fly.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package hide-mode-line
  :after general
  :defer t
  :init
  (nto/leader
	"tm" '(hide-mode-line-mode :wk "modeline")))
#+end_src
*** Doom modeline
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :config
  (setq doom-modeline-support-imenu t)
  (setq doom-modeline-height 25)
  (setq doom-modeline-bar-width 4)
  (setq doom-modeline-lsp-icon nil))
#+end_src

*** Icons support
Just installed, need configuration.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package all-the-icons
  :if (display-graphic-p))

(use-package nerd-icons
  ;; :custom
  ;; The Nerd Font you want to use in GUI
  ;; "Symbols Nerd Font Mono" is the default and is recommended
  ;; but you can use any other Nerd Font if you want
  ;; (nerd-icons-font-family "Symbols Nerd Font Mono")
  )
#+end_src

*** Built in ui configuration
Ui settings that are not that important so they can be setted later during the init process.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package emacs
  :after general
  :init
  (setq hl-line-sticky-flag nil) 
  (hl-line-mode +1)
  (nto/leader
    "tL" '(hl-line-mode :wk "highlight line")
	"tb" '(toggle-frame-tab-bar :wk "tabs")))
#+end_src

*** Keycast  
Display the current key pressed and the corresponding command in tab bar or modeline.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package keycast
  :after general
  :defer t
  :init
  (nto/leader
	"tk" '(keycast-mode-line-mode :wk "keycast (modeline)")
	"tK" '(keycast-tab-bar-mode :wk "keycast (tab bar)")))
#+end_src

*** RGB colors utils
Package related to the colors in ui:
+ *rainbow-mode*, display hexdecimal color inline, i.e. #00ff00 will appear green
+ *rainbow-delimiter*, color matching parentheses with same color to enhance readability
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package rainbow-mode
  :defer t)  

(use-package rainbow-delimiters
  :defer t
  :hook (prog-mode . rainbow-delimiters-mode)
  :config
  (setq rainbow-delimiters-max-face-count 4)) ;; copied from doom, avoid to many colors and should improve performance
#+end_src

*** Theming
**** Installed themes
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package gruber-darker-theme)
(use-package ef-themes)
(use-package doom-themes)
(use-package anti-zenburn-theme)
(use-package cyberpunk-theme)
(use-package spacemacs-theme)
(use-package tron-legacy-theme)
(use-package nano-theme)
#+end_src

**** Setting theme on startup
In *init.el* are defined 2 themes, one called *selected* used to set the theme on startup, and other is called *default* used as a fallback, mainly used on first startup of this config on a new machine.
I've made a little function to set the theme, if the *selected* is not available it use the *default*.
Obviously the *default* should always be one the pre installed themes, although there are no checks regarding it. 
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(defun nto/load-theme-or-default(selected default)
  "If `selected' is available load it, otherwise load `default'"
  (if (memq selected (custom-available-themes))
	  (load-theme selected)
	(load-theme default)))

(nto/load-theme-or-default selected-theme default-theme)
#+end_src

*** End
Module ~init-ui.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(provide 'init-ui)
#+end_src

** Module ~init-writing.el~ 
Package more related to writing more than editing
*** Google translate
A great package to query google translate, it work pretty well with word at point and selected region.
#+begin_src emacs-lisp :tangle "lisp/init-writing.el" :mkdirp yes
(use-package google-translate
  :after general
  :config
  (push "\\*Google Translate\\*"  popper-reference-buffers)
  :init
  (setq google-translate-translation-directions-alist
        '(("it" . "en") ("en" . "it")))
  (setq google-translate-default-source-language "it")
  (setq google-translate-default-target-language "en")
  (nto/leader
	"lp" '(google-translate-at-point :wk "translate (it -> en)")
	"lP" '(google-translate-at-point-reverse :wk "translate (en -> it)")))
#+end_src

*** TODO Powerthesaurus
The [[https://www.powerthesaurus.org/it%27s_raining_cats_and_dogs/synonyms][powerthesaurus]] service let you search for synonyms, atonyms and other stuff.
Thankfully there is a front end for emacs.
I use it, for now, only in org mode, so I've used the local leader in this case.
#+begin_src emacs-lisp :tangle "lisp/init-writing.el" :mkdirp yes
(use-package powerthesaurus
  :after general
  :defer t
  :init
  (nto/local-leader
	:keymaps 'org-mode-map
    "T" '(:ignore t :wk "powerthesaurus")
	"Tt" '(powerthesaurus-lookup-dwim :wk "become")
	"Ts" '(powerthesaurus-lookup-synonyms-dwim :wk "synonyms")
	"Ta" '(powerthesaurus-lookup-antonyms-dwim :wk "antonyms")
	"Tr" '(powerthesaurus-lookup-related-dwim :wk "related")
	"Td" '(powerthesaurus-lookup-definitions-dwim :wk "definitions")
	"TS" '(powerthesaurus-lookup-Sentence-dwim :wk "sentence")))
#+end_src

*** TODO Synstax check
Actually I don't even know if the are mutually exclusive.
+ Configure ispell
+ Configure flyspell
+ Checkout jinx

*** End
Module ~init-writing.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-writing.el" :mkdirp yes
(provide 'init-writing)
#+end_src

** Module ~init-font.el~
Section about font configuration.

*** Set preferred encoding
#+begin_src emacs-lisp :tangle "lisp/init-font.el" :mkdirp yes
(set-charset-priority 'unicode)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(setq locale-coding-system 'utf-8
	  coding-system-for-read 'utf-8
	  coding-system-for-write 'utf-8
	  default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

*** Set font 
#+begin_src emacs-lisp :tangle "lisp/init-font.el" :mkdirp yes
(defun nto/set-font-all (selected)
  "Set `selected' font to all the faces, this will apply only if the `selected' font is found in the system"
  (when (find-font (font-spec :name selected))
	(set-face-attribute 'default nil :font selected :height my-font-height)
	(set-face-attribute 'fixed-pitch nil :font selected :height my-font-height)
	(set-face-attribute 'variable-pitch nil :font selected :height my-font-height :weight 'regular)))

(nto/set-font-all selected-font)
#+end_src

*** End
Module ~init-font.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-font.el" :mkdirp yes
(provide 'init-font)
#+end_src

** Module ~init-window.el~
Section related to window manipulation and navigation.
*** Built in commands
#+begin_src emacs-lisp :tangle "lisp/init-window.el" :mkdirp yes
(use-package emacs
  :after general
  :init
  (nto/leader
	"w" '(:ignore t :wk "window")
	"wv" '(evil-window-vsplit :wk "split V")
	"ws" '(evil-window-split :wk "split H")
	"w1" '(delete-other-windows :wk "delete others")
	"w!" '(ace-delete-other-windows :wk "(ACE) delete others")
	"w0" '(delete-windows :wk "delete")
	"wq" '(ace-delete-window :wk "(ACE) delete")
	"wS" '(ace-swap-window :wk "(ACE) swap")
	"wh" '(windmove-left :wk "move left")
	"wj" '(windmove-down :wk "move down")
	"wk" '(windmove-up :wk "move up")
	"wl" '(windmove-right :wk "move right")
	"wH" '(windmove-swap-states-left :wk "swap left")
	"wJ" '(windmove-swap-states-down :wk "swap down")
	"wK" '(windmove-swap-states-up :wk "swap up")
	"wL" '(windmove-swap-states-right :wk "swap right")
	"wc" '(delete-window :wk "delete")
	"w=" '(balance-windows-area :wk "equal")
	"wD" '(kill-buffer-and-window :wk "kill buffer and window")
	"wm" '(delete-other-windows :wk "maximize")
	"wu" '(winner-undo :wk "undo")
	"wU" '(winner-redo :wk "redo")))
#+end_src

*** Rotate windows and layout
The *rotate* package let me cycle between different layout which is often convenient, it also exposse some functions to rotate the currently visible buffers.
#+begin_src emacs-lisp :tangle "lisp/init-window.el" :mkdirp yes
(use-package rotate
  :after general
  :init
  (setq rotate-functions '(rotate:even-horizontal
                           rotate:even-vertical
                           rotate:main-horizontal
                           rotate:main-vertical
                           rotate:tiled))
  (nto/leader
	"wr" '(rotate-window :wk "window")
	"wR" '(rotate-layout :wk "layout")
	"rr" '(rotate-window :wk "window")
	"rl" '(rotate-layout :wk "layout")))
#+end_src

*** Golden Ratio
Open window respecting the golden ratio, a la [[https://github.com/baskerville/bspwm][bspwm]].
Enlarge the currently focused buffer and shrink the others to respect the ratio, it is not enabled by default.
#+begin_src emacs-lisp :tangle "lisp/init-window.el" :mkdirp yes
(use-package golden-ratio
  :after general
  :config
  (setq golden-ratio-adjust-factor 1.0)
  :init
  (nto/leader
	"tg" '(golden-ratio-mode :wk "golden ratio")))
#+end_src

*** Ace Window
The *ace-window* package define some function to operate on window based on enumeration, the simplest feature is jumping between them, but it provide a lot more than that.
To see all the possible action press src_emacs-lisp{(kbd "?")} while there is *ace-window* overlay.
#+begin_src emacs-lisp :tangle "lisp/init-window.el" :mkdirp yes
(use-package ace-window
  :after general
  :config
  (setq aw-scope 'frame)
  :init
  (setq aw-dispatch-always nil)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (defvar aw-dispatch-alist
	'((?x aw-delete-window "Delete Window")
	  (?m aw-swap-window "Swap Windows")
	  (?M aw-move-window "Move Window")
	  (?c aw-copy-window "Copy Window")
	  (?j aw-switch-buffer-in-window "Select Buffer")
	  (?n aw-flip-window "Flip window")
	  (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
      (?e aw-execute-command-other-window "Execute Command Other Window")
	  (?c aw-split-window-fair "Split Fair Window")
	  (?v aw-split-window-vert "Split Vert Window")
	  (?b aw-split-window-horz "Split Horz Window")
	  (?o delete-other-windows "Delete Other Windows")
	  (?? aw-show-dispatch-help))
	"List of actions for `aw-dispatch-default'.")
  :general
  (nto/leader
    "ww" '(ace-window :wk "ace window")))
#+end_src

*** End
Module ~init-window.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-window.el" :mkdirp yes
(provide 'init-window)
#+end_src

** Module ~init-workspaces.el~
*** Tab Bar Mode
Built in mode to handle workspace, also provide a tab ui.
Doesn't provide a way to isolate related buffer from each other, maybe this can be fixed with [[https://protesilaos.com/emacs/beframe][Beframe]].
#+begin_src emacs-lisp :tangle "lisp/init-workspaces.el" :mkdirp yes
(use-package tab-bar
  :after general
  :config
  (setq tab-bar-button-relief 5)
  (nto/leader
	"<tab>" '(:ignore t :wk "workspaces")
	"<tab> <tab>" '(tab-switch :wk "switch")
	"<tab> n" '(tab-new :wk "new")
	"<tab> b" '(switch-to-buffer-other-tab :wk "buffer")
	"<tab> d" '(dired-other-tab :wk "dired")
	"<tab> f" '(find-file-other-tab :wk "find file")
	"<tab> c" '(tab-close :wk "close")
	"<tab> r" '(tab-rename :wk "rename")
	"<tab> u" '(tab-undo :wk "undo")
	"<tab> j" '(tab-next :wk "next")
	"<tab> k" '(tab-previous :wk "prev")))
#+end_src

*** End
Module ~init-workspaces.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-workspaces.el" :mkdirp yes
(provide 'init-workspaces)
#+end_src

** Module ~init-magit.el~
*** Install Magit
#+begin_src emacs-lisp :tangle "lisp/init-magit.el" :mkdirp yes
(use-package magit
  :after general
  :defer t
  :init
  (nto/leader
	"gg" '(magit-status :wk "status")))
#+end_src

*** Install Forge
#+begin_src emacs-lisp :tangle "lisp/init-magit.el" :mkdirp yes
(use-package forge
  :after magit
  :defer t)
#+end_src

*** Install Magit Todos
#+begin_src emacs-lisp :tangle "lisp/init-magit.el" :mkdirp yes
(use-package magit-todos
  :after magit
  :config
  (magit-todos-mode 1))
#+end_src

*** TODO Setup merge tool
*** Smerge
#+begin_src emacs-lisp :tangle "lisp/init-magit.el" :mkdirp yes
(use-package smerge
  :straight (:type built-in)
  :after magit
  :init
  (nto/local-leader
	:keymaps 'smerge-mode-map
	"j" '(smerge-keep-lower :wk "keep lower")
	"k" '(smerge-keep-upper :wk "keep upper")
	"n" '(smerge-next :wk "next")
	"p" '(smerge-prev :wk "previous")
	"r" '(smerge-resolve :wk "resolve")))
#+end_src
*** End
Module ~init-magit.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-magit.el" :mkdirp yes
(provide 'init-magit)
#+end_src

** Module ~init-project.el~
*** Setup projectile
#+begin_src emacs-lisp :tangle "lisp/init-project.el" :mkdirp yes
(use-package projectile
  :defer t
  :config
  (setq projectile-sort-order 'recently-active)
  :init
  (nto/leader
	"pf" '(projectile-find-file :wk "find")
	"pF" '(projectile-find-file-in-known-projects :wk "find all")
	"pd" '(projectile-dired :wk "dired")
    "pg" '(projectile-grep :wk "grep")
    "pr" '(projectile-ripgrep :wk "ripgrep")
	"p?" '(projectile-find-references :wk "reference")
    "ph" '(projectile-find-other-file :wk "interface <-> impl")
	"pp" '(projectile-switch-project :wk "switch")
    "pt" '(projectile-test-project :wk "run test")
    "pc" '(projectile-compile-project :wk "compile")
    "p&" '(projectile-run-async-shell-command-in-root :wk "run command"))
  (projectile-mode +1)
  :bind-keymap
  ("C-c p" . projectile-command-map))
#+end_src

*** Browse open on github
Open current file directly on github, while in a github repo.
#+begin_src emacs-lisp :tangle "lisp/init-project.el" :mkdirp yes
(use-package github-browse-file
  :defer t
  :init
  (nto/leader
	"pG" '(github-browse-file :wk "see on Gh")
	"pB" '(github-browse-file-blame :wk "blame on Gh")))
#+end_src

*** Highlight diff
Show, on the fringe, the diff between versions.
#+begin_src emacs-lisp :tangle "lisp/init-project.el" :mkdirp yes
(use-package diff-hl
  :init
  (global-diff-hl-mode))
#+end_src

*** Highlight todo
Highlight todo in project (more properly globally), also define shortcuts to navigate between them.
#+begin_src emacs-lisp :tangle "lisp/init-project.el" :mkdirp yes
(use-package hl-todo
  :after general
  :init
  (global-hl-todo-mode 1)
  (nto/leader
	"tt" '(:ignore t :wk "todos")
	"ttt" '(global-hl-todo-mode :wk "toggle")
	"ttp" '(hl-todo-previous :wk "previous")
	"ttn" '(hl-todo-next :wk "next")
	"tto" '(hl-todo-occur :wk "occur")
	"tti" '(hl-todo-insert :wk "insert")))

(use-package consult-todo
  :after general
  :init
  (nto/leader
	"ft" '(consult-todo-all :wk "consult todo")))
#+end_src

*** End
Module ~init-project.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-project.el" :mkdirp yes
(provide 'init-project)
#+end_src

** Module ~init-embark.el~
Recently I've read [[https://karthinks.com/software/fifteen-ways-to-use-embark/][fifteen ways to use embark]] and it is a game changing, although it require a little bit of effort to enter in my workflow.
*** Install embark
#+begin_src emacs-lisp :tangle "lisp/init-embark.el" :mkdirp yes
(use-package embark
  :init
  (global-set-key (kbd "C-,") #'embark-act)
  (global-set-key (kbd "M-,") #'embark-dwim)
  (setq prefix-help-command #'embark-prefix-help-command)
  (nto/leader
	"a" '(:ignore t :wk "embark")
	"aa" '(embark-act :wk "act")
	"ad" '(embark-dwim :wk "dwim")
	"ab" '(embark-become :wk "become")
	"ac" '(embark-collect :wk "collect"))
  :config
  (add-to-list 'display-buffer-alist
			   '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
				 nil
				 (window-parameters (mode-line-format . none)))))

(use-package embark-consult
  :after '(embark consult)
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Embark extra, ace window action
Copied from the *karthinks* article.
#+begin_src emacs-lisp :tangle "lisp/init-embark.el"  :mkdirp yes
(with-eval-after-load 'embark
  (eval-when-compile
	(defmacro nto/embark-ace-action (fn)
	  `(defun ,(intern (concat "nto/embark-ace-" (symbol-name fn))) ()
		 (interactive)
		 (with-demoted-errors "%s"
		   (require 'ace-window)
		   (let ((aw-dispatch-always t))
			 (aw-switch-to-window (aw-select nil))
			 (call-interactively (symbol-function ',fn)))))))

  ;; RMB: work when there are at least 3 window
  (define-key embark-file-map (kbd "o") (nto/embark-ace-action find-file))
  (define-key embark-buffer-map (kbd "o") (nto/embark-ace-action switch-to-buffer))
  (define-key embark-bookmark-map (kbd "o") (nto/embark-ace-action bookmark-jump)))
#+end_src

*** Embark extra, split actions
Also copied from the *karthinks* article.
#+begin_src emacs-lisp :tangle "lisp/init-embark.el" :mkdirp yes
(with-eval-after-load 'embark
  (eval-when-compile
	(defmacro nto/embark-split-action (fn split-type)
      `(defun ,(intern (concat "nto/embark-"
							   (symbol-name fn)
							   "-"
							   (car (last  (split-string
											(symbol-name split-type) "-")))))
		   (interactive)
		 (funcall #',split-type)
		 (call-interactively #',fn))))

  (define-key embark-file-map     (kbd "s") (nto/embark-split-action find-file split-window-below))
  (define-key embark-buffer-map   (kbd "s") (nto/embark-split-action switch-to-buffer split-window-below))
  (define-key embark-bookmark-map (kbd "s") (nto/embark-split-action bookmark-jump split-window-below))

  (define-key embark-file-map     (kbd "v") (nto/embark-split-action find-file split-window-right))
  (define-key embark-buffer-map   (kbd "v") (nto/embark-split-action switch-to-buffer split-window-right))
  (define-key embark-bookmark-map (kbd "v") (nto/embark-split-action bookmark-jump split-window-right)))
#+end_src

*** End
Module ~init-embark.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-embark.el" :mkdirp yes
(provide 'init-embark)
#+end_src

** Module ~init-term.el~
Terminal emulator from within emacs.
*** Vterm
Vterm should be installed only if the OS is not windows (10, 11 or whatever) based.
#+begin_src emacs-lisp :tangle "lisp/init-term.el" :mkdirp yes
(when (not (eq system-type 'windows-nt))
  (use-package vterm
	:after general
	:demand t)

  (use-package vterm-toggle
	:after vterm
	:init
	(nto/leader
	  "ot" '(vterm-toggle :wk "vterm"))))
#+end_src
*** Powershell 
Emacs integration for windows powershell, see [[https://github.com/jschaf/powershell.el][here]].
#+begin_src emacs-lisp :tangle "lisp/init-term.el" :mkdirp yes
(when (eq system-type 'windows-nt)
  (use-package powershell
	:after general
	:straight (powershell :type git
						  :host github
						  :repo "jschaf/powershell.el")
	:init
	(nto/leader
	  "ot" '(powershell :wk "powershell"))))
#+end_src
*** Eshell
Emacs shell configuration.
#+begin_src emacs-lisp :tangle "lisp/init-term.el" :mkdirp yes
(use-package eshell
  :init
  (setq eshell-scroll-to-bottom-on-input 'all
		eshell-error-if-no-glob t
		eshell-hist-ignoredups t
		eshell-save-history-on-exit t
		eshell-prefer-lisp-functions nil
		eshell-destroy-buffer-when-process-dies t))

(use-package eshell-toggle
  :after general
  :init
  (nto/leader
	"oe" '(eshell-toggle :wk "eshell")))
#+end_src

**** TODO checkout:
+ [[https://github.com/manateelazycat/aweshell][aweshell]]
+ define custom alias
+ integrate with elisp code

*** End
Module ~init-term.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-term.el" :mkdirp yes
(provide 'init-term)
#+end_src

** Module ~init-mouse.el~
Sometime use the mouse is not that bad.
Remember to registry new strokes with src_emacs-lisp{strokes-global-set-stroke}.
A nice one to set up are:
+ =~= to open dired on home directory
*** Setup strokes, mainly for laptop
Read about strokes [[https://karthinks.com/software/different-strokes-for-different-folks/][here]].
**** Utility 
#+begin_src emacs-lisp :tangle "lisp/init-mouse.el" :mkdirp yes
(defun nto/dired-home ()
  "open dired at home"
  (interactive)
  (dired "~/"))
#+end_src
**** Mouse bindings 
#+begin_src emacs-lisp :tangle "lisp/init-mouse.el" :mkdirp yes
(keymap-global-set "C-<down-mouse-1>" 'strokes-do-stroke)
(keymap-global-set "<down-mouse-3>" 'mouse-buffer-menu)
#+end_src
*** Enable mouse support in terminal
See the [[https://emacsredux.com/blog/2022/06/03/enable-mouse-support-in-terminal-emacs/][this]] article by *bbatsov*.
#+begin_src emacs-lisp :tangle "lisp/init-mouse.el" :mkdirp yes
(unless (display-graphic-p)
  (if (eq system-type 'gnu/linux)
	  (gpm-mouse-mode 1)
	(xterm-mouse-mode 1)))
#+end_src

*** End
Module ~init-mouse.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-mouse.el" :mkdirp yes
(provide 'init-mouse)
#+end_src

** Module ~init-browser.el~
*** Google search
This utility will be loaded only if emacs is in a graphical environment.
#+begin_src emacs-lisp :tangle "lisp/init-browser.el" :mkdirp yes
(with-eval-after-load 'general
  (when (display-graphic-p)
	(defun nto/google-search ()
	  "perform a goole search with region, or prompt for a search term, in the minibuffer."
	  (interactive)
	  (let ((base-url "https://google.com/search?q=%s")
			(param (if (region-active-p)
					   (nto/get-string-from-region)
					 (read-from-minibuffer "Google search: "))))
		(browse-url (nto/build-url base-url param))))

	(nto/leader
	  "sg" '(nto/google-search :wk "google"))))
#+end_src

*** End
Module ~init-browser.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-browser.el" :mkdirp yes
(provide 'init-browser)
#+end_src

** Module ~init-os.el~
Section for os specific settings.
*** Windows
Setup home directory on windows, for now it is hardcoded.
#+begin_src emacs-lisp :tangle "lisp/init-os.el" :mkdirp yes
(when (eq system-type 'windows-nt)
    (setq default-directory windows-default-directory))
#+end_src

*** GNU/Linux
Nothing to see here, for now.
*** Mac
Add latex compile path.
#+begin_src emacs-lisp :tangle "lisp/init-os.el" :mkdirp yes
(when (eq system-type 'darwin)
  (setenv "PATH"
		  (concat "/Library/TeX/texbin" ":"
				  (getenv "PATH"))))
#+end_src

*** End
Module ~init-os.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-os.el" :mkdirp yes
(provide 'init-os)
#+end_src

** Module ~init-prog.el~
*** TODO Setup for treesitter
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package tree-sitter
  :config
  (setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
	 (gleam "https://github.com/gleam-lang/tree-sitter-gleam")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml"))))

(use-package tree-sitter-langs)

(use-package tree-sitter-indent)

(use-package treesit-auto
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src
*** TODO Setup for eglot
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package eglot)
#+end_src
*** Language support
**** Go lang
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package go-mode)
#+end_src
**** Zig lang
For now I don't plan to use LSP with zig.
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package zig-mode)
#+end_src

**** Python lang
For occasional scripting
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package python-mode)
#+end_src

**** Lua lang
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package lua-mode)
#+end_src

**** Lox lang
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package lox-mode)
#+end_src

**** Clojure lang
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package clojure-ts-mode)
(use-package clojure-mode)
(use-package cider)
#+end_src

**** Elm language
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package elm-mode)
#+end_src

**** Ocaml language
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package tuareg)
#+end_src

**** Gleam language
There is minor bug for now, I need to symlink the treesitter-gleam from repos to build (under straight folder)
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(use-package gleam-mode
  :straight (gleam-mode :type git
						:host github
						:repo "gleam-lang/gleam-mode"
						:nonrecursive nil))
#+end_src
*** End
Module ~init-prog.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes
(provide 'init-prog)
#+end_src

** Module ~init-app.el~
*** Apps to add
+ emms (on linux)
+ pdf, nov.el, pen.el
+ restclient
+ plantuml
+ gptel

*** Screenshot
I seldom use this functionality, nonetheless it is pretty nice when needed.
I prefer not to bind any key for this functionality.
#+begin_src emacs-lisp :tangle "lisp/init-app.el" :mkdirp yes
(use-package screenshot)
#+end_src

*** Selectric
The power of emacs with the sound of a typewriter, just perfect.
#+begin_src emacs-lisp :tangle "lisp/init-app.el" :mkdirp yes
(use-package selectric-mode
  :commands selectric-mode)
#+end_src

*** IRC
Setup ERC, irc client for emacs.
#+begin_src emacs-lisp :tangle "lisp/init-app.el" :mkdirp yes
(use-package erc
  :init
  (defun start-irc ()
	"Connect to irc."
	(interactive)
	(when (y-or-n-p (format "connect to: %s?" my-erc-server))
	  (erc-tls :server my-erc-server
			   :port my-erc-port
			   :nick my-erc-nick
			   :full-name my-erc-full-name
			   :password my-erc-passwd
			   :client-certificate t)))
  :config
  (require 'erc-autoaway)

  ;; connection params
  (setq erc-server my-erc-server
		erc-nick my-erc-nick
		erc-user-full-name my-erc-full-name
		erc-track-shorten-start 8
		erc-autojoin-channels-alist my-erc-autojoin-channels
		erc-kill-buffer-on-part t
		erc-auto-query 'bury)
  ;; erc config
  (setq erc-interpret-mirc-color t
		erc-kill-buffer-on-part t
		erc-kill-queries-on-quit t
		erc-kill-server-buffer-on-quit t

		erc-autoaway-idle-method 'user
		erc-auto-discard-away t
		erc-autoaway-idle-seconds 600))
#+end_src

*** End
Module ~init-app.el~ ends here
#+begin_src emacs-lisp :tangle "lisp/init-app.el" :mkdirp yes
(provide 'init-app)
#+end_src

*~/.emacs.d/~/.emacs.d/* Module ~init-exwm.el~
I'm givin another shot to exwm, the concept is really awesome but it always fell a little bit clumsy.
*** Install exwm
#+begin_src emacs-lisp :tangle "lisp/init-exwm.el" :mkdirp yes
(when (eq system-type 'gnu/linux)
  (use-package exwm
	:config
	;; make more room for x11 windows
	(menu-bar-mode -1)
	;; battery status in modeline
	(display-battery-mode)

	;; time display in modeline
	(display-time-mode)

	(setq exwm-workspace-number 9)

	;; system tray
	(require 'exwm-systemtray)
	(exwm-systemtray-enable)
	(setq exwm-systemtray-height 15)

	;; multi monitor
	(require 'exwm-randr)
	;; config randr
	(setq exwm-randr-workspace-monitor-plist '(0 "eDP" 1 "DisplayPort-3"))

	(exwm-randr-enable)

	(setq nto/layout "us")

	(setq exwm-input-global-keys
		  `(
			(,(kbd "s-r") . exwm-reset)
			(,(kbd "s-w") . exwm-workspace-switch)
			(,(kbd "s-m") . exwm-workspace-move-window)

			,@(mapcar (lambda (i)
						`(,(kbd (format "s-%d" i)) .
						  (lambda ()
							(interactive)
							(exwm-workspace-switch-create ,i))))
					  (number-sequence 0 9))

			(,(kbd "s-f") . exwm-layout-toggle-fullscreen)
			(,(kbd "s-F") . exwm-floating-toggle-floating)

			(,(kbd "s-q") . delete-window)
			(,(kbd "s-o") . ace-window)

			(,(kbd "s-h") . windmove-left)
			(,(kbd "s-j") . windmove-down)
			(,(kbd "s-k") . windmove-up)
			(,(kbd "s-l") . windmove-right)

			(,(kbd "s-H") . (lambda () (interactive) (exwm-layout-shrink-window-horizontally 20)))
			(,(kbd "s-J") . (lambda () (interactive) (exwm-layout-shrink-window 20)))
			(,(kbd "s-K") . (lambda () (interactive) (exwm-layout-enlarge-window 20)))
			(,(kbd "s-L") . (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 20)))

			(,(kbd "s-i") . (lambda ()
							  (interactive)
							  (if (string= nto/layout "us")
								  (progn
									(setq nto/layout "us-intl")
									(start-process "" nil "/usr/bin/setxkbmap" "us" "-variant" "intl" "-option" "ctrl:nocaps")
									(message "switching to us intl"))
								(progn
								  (setq nto/layout "us")
								  (start-process "" nil "/usr/bin/setxkbmap" "us" "-option" "ctrl:nocaps")
								  (message "switching to us")))))))

	(setq exwm-floating-border-width 5)

	(add-hook 'exwm-update-class-hook
			  (lambda ()
				(unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
							(string= "gimp" exwm-instance-name))
				  (exwm-workspace-rename-buffer exwm-class-name))))
	(add-hook 'exwm-update-title-hook
			  (lambda ()
				(when (or (not exwm-instance-name)
						  (string-prefix-p "sun-awt-X11-" exwm-instance-name)
						  (string= "gimp" exwm-instance-name))
				  (exwm-workspace-rename-buffer exwm-title))))

	(setq exwm-input-simulation-keys
		  '(([?\C-b] . [left])
			([?\C-f] . [right])
			([?\C-p] . [up])
			([?\C-n] . [down])
			([?\C-a] . [home])
			([?\C-e] . [end])
			([?\M-v] . [prior])
			([?\C-v] . [next])
			([?\C-d] . [delete])
			([?\C-k] . [S-end delete])
			([?\C-s] . [?\C-f])))

	(add-hook 'exwm-init-hook
			  (lambda ()
				(progn
				  ;; setup composite transparency and background
				  (start-process "" nil "/usr/bin/picom" "-b")
				  ;; setup italian layout for keyboard
				  (start-process "setxkbmap" nil "/usr/bin/setxkbmap" "us" "-option" "ctrl:nocaps")))))

  (use-package exwm-modeline
	:if (eq system-type 'gnu/linux)
	:after exwm
	:init
	(add-hook 'exwm-init-hook #'exwm-modeline-mode))

  (use-package counsel
	:if (eq system-type 'gnu/linux)
	:after exwm
	:init
	(exwm-input-set-key (kbd "s-d") #'counsel-linux-app)))
#+end_src
*** End
Module ~init-exwm.el~ ends here.
#+begin_src emacs-lisp :tangle "lisp/init-exwm.el" :mkdirp yes
(provide 'init-exwm)
#+end_src
